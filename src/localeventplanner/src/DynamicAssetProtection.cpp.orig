/*
* @file DynamicAssetProtection.cpp
*
* @brief Provides functions for dynamic asset protection
*/
#include "DynamicAssetProtection.h"
#include "SessionEncryption.h" // Oturum þifreleme fonksiyonlarý için
#include <iostream>
#include <iomanip>
#include <sstream>
#include <vector>
#include <cstring> // memset için
#include <openssl/buffer.h>
#include <openssl/sha.h>  // SHA-256 için gerekli
#include <openssl/evp.h>  // Þifreleme için gerekli
#include <openssl/rand.h> // Rastgele veri için gerekli
#include <iostream>
#include <sstream>
#include <iomanip>
#include <vector>
#include <cstring>
#include "DisplayMainMenu.h"

#ifdef _WIN32
#include <windows.h>

/*
* @brief Executes a command and returns the output
*
* @param cmd Command to execute
*
* @return std::string
*/
// Windows için komut çalýþtýrma
std::string executeCommand(const char* cmd) {
  char buffer[128]; // Komutun çýktýsýný depolamak için buffer
  std::string result; // Sonuç string'i
  FILE* pipe = _popen(cmd, "r"); // Komutun çýktýsýný okumak için pipe açýlýr

  if (!pipe) return "ERROR"; // Pipe açýlmazsa hata döndür

  while (fgets(buffer, sizeof(buffer), pipe) != nullptr) { // Çýktýyý satýr satýr oku
    result += buffer; // Çýktýyý birleþtir
  }

  _pclose(pipe); // Pipe'i kapat
  return result; // Sonuç döndür
}

/*
* @brief Gets device information on Windows
*
* @return std::string
*/
// Windows cihaz bilgisi alma
std::string getDeviceInfo() {
  std::string osInfo = executeCommand("systeminfo | findstr /B /C:\"OS\""); // Ýþletim sistemi bilgilerini al
  std::string cpuInfo; // CPU bilgisi depolamak için deðiþken
  HKEY hKey; // Registry anahtarý
  char cpuName[256]; // CPU ismini saklamak için buffer
  DWORD bufferSize = sizeof(cpuName); // Buffer boyutu

  // Registry'den CPU ismini al
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
                   0, KEY_READ, &hKey) == ERROR_SUCCESS) {
    RegQueryValueEx(hKey, "ProcessorNameString", NULL, NULL, (LPBYTE)cpuName, &bufferSize);
    RegCloseKey(hKey); // Registry anahtarýný kapat
    cpuInfo = std::string(cpuName); // CPU bilgisi string'e dönüþtür
  } else {
    cpuInfo = "Unknown CPU"; // Eðer hata varsa "Unknown CPU" döndür
  }

  return osInfo + "CPU: " + cpuInfo; // Ýþletim sistemi ve CPU bilgisini birleþtirerek döndür
}

#else // Linux ve diðer platformlar

#include <cstdlib>
#include <cstdio>

std::string executeCommand(const char* cmd) {
  char buffer[128]; // Komut çýktýsýný depolamak için buffer
  std::string result; // Sonuç string'i
  FILE* pipe = popen(cmd, "r"); // Komutun çýktýsýný okumak için pipe açýlýr

  if (!pipe) return "ERROR"; // Pipe açýlmazsa hata döndür

  while (fgets(buffer, sizeof(buffer), pipe) != nullptr) { // Çýktýyý satýr satýr oku
    result += buffer; // Çýktýyý birleþtir
  }

  pclose(pipe); // Pipe'i kapat
  return result; // Sonuç döndür
}

// Linux cihaz bilgisi alma
std::string getDeviceInfo() {
  std::string osInfo = executeCommand("uname -a"); // Ýþletim sistemi bilgilerini al
  std::string cpuInfo = executeCommand("lscpu | grep 'Model name:'"); // CPU bilgilerini al
  return osInfo + "CPU: " + cpuInfo; // Ýþletim sistemi ve CPU bilgilerini birleþtirerek döndür
}

#endif

/*
* @brief SHA-256 hash function
*
* @param input Input string to hash
*
* @return std::string
*/
// SHA-256 hash fonksiyonu
std::string sha256(const std::string& input) {
  unsigned char hash[SHA256_DIGEST_LENGTH]; // SHA-256 hash çýktýsýný depolamak için buffer
  SHA256(reinterpret_cast<const unsigned char*>(input.c_str()), input.size(), hash); // SHA-256 ile hash iþlemi
  std::ostringstream result; // Hash sonucunu string'e dönüþtürmek için string stream

  for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) { // Hash verisini döngüyle oku
    result << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i]; // Hex formatýnda string'e ekle
  }

  return result.str(); // Hash sonucunu döndür
}

/*
* Unnecessary function for testing
* 
* @param value Value to check
* 
* @return bool
*/


bool sxslioufdw(int value) {
    if (value < 2) return false;
    for (int i = 2; i <= std::sqrt(value); ++i) {
        if (value % i == 0) return false;
    }
    return true;
}

/*
* @brief Unnecessary function for testing
* 
* @return void
*/


void ttassqqxcfd() {
    std::vector<int> data = { 1, 2, 3, 4, 5, 6, 7, 16, 25, 30 };
    std::vector<int> additionalData = { 12, 18, 22, 36, 45, 60, 72 };
    std::vector<int> finalData = { 101, 202, 303, 404, 505 };

    // Gereksiz deðiþkenler
    int evenCount = 0, oddCount = 0, primeCount = 0;
    int sumMultiplesOfFive = 0, perfectSquareCount = 0;
    int divisibleByThreeCount = 0, digitSumGreaterThanTen = 0;
    long long unnecessaryComputationSum = 0, totalIterations = 0;
    long long specialConditionCount = 0, modSevenCount = 0;
    double accumulatedSquareRoots = 0.0;
    int totalDigitProduct = 1;

    // Gereksiz deðiþkenler
    int a = 0;
    int b = 1;
    int c = 2;
    int d = 3;

    int uselessCalculation1 = 0;
    int uselessCalculation2 = 0;
    int uselessCalculation3 = 0;

    for (int value : data) {
        totalIterations++;

        // Gereksiz iþlemler
        int intermediate = value * 3;
        intermediate += 7;
        intermediate -= 7;
        intermediate /= 2;
        intermediate *= value % 5;
        intermediate += 1 - 1;
        unnecessaryComputationSum += intermediate;
        int e = 4;
        int f = 5;
        int g = 6;
        int h = 7;
        int i = 8;
        int j = 9;
        a = a + 1 - 1 + 2 - 2; // Daha fazla gereksiz iþlem
        b = b * 2 / 2 + 5 - 5;
        c = c + a - b + 3 - 3;
        d = d * 4 / 4 - c + 6 - 6;

        if (value % 2 == 0) {
            evenCount++;
            continue;
        }
        oddCount++;

        if (sxslioufdw(value)) {
            primeCount++;
        }

        if (value % 5 == 0) {
            sumMultiplesOfFive += value;
        }

        int sqrtValue = std::sqrt(value);
        if (sqrtValue * sqrtValue == value) {
            perfectSquareCount++;
        }

        if (value % 3 == 0) {
            divisibleByThreeCount++;
        }

        if (value % 7 == 0) {
            modSevenCount++;
        }

        int digitSum = 0, digitProduct = 1;
        int temp = value;
        while (temp > 0) {
            int digit = temp % 10;
            digitSum += digit;
            digitProduct *= digit;
            temp /= 10;

            uselessCalculation1 = uselessCalculation1 + digit - digit;
            uselessCalculation2 = uselessCalculation2 * digit / (digit == 0 ? 1 : digit);
            uselessCalculation3 = uselessCalculation3 + digitProduct - digitProduct;
        }

        if (digitSum > 10) {
            digitSumGreaterThanTen++;
        }

        totalDigitProduct *= (digitProduct % 1000);
        accumulatedSquareRoots += std::sqrt(value);

        if (value % 2 == 0 && value % 3 == 0) {
            specialConditionCount++;
        }

        unnecessaryComputationSum += digitSum * 5 - value / 3 + 17;
    }

    for (int value : additionalData) {
        int dummyCalculation = value * 2 + 3 - 3;
        dummyCalculation *= dummyCalculation % 10 + 1 - 1;
        accumulatedSquareRoots += std::sqrt(dummyCalculation);
        unnecessaryComputationSum += dummyCalculation % 10 + 4 - 4;
    }

    for (int value : finalData) {
        int dummyCalculation = value * 3 - 5 + 5 - 5;
        dummyCalculation *= 2;
        accumulatedSquareRoots += std::sqrt(dummyCalculation);
        unnecessaryComputationSum += dummyCalculation % 20 + 8 - 8;
    }

    // Daha fazla gereksiz deðiþken
    int p = 10;
    int q = 20;
    int r = 30;
    int s = 40;
    int t = 50;
    p = p + q - r + s - t;
    q = q * 2 - p + r - s + t;
    r = r * 3 / 3 + q - p;
}

/*
* @brief Encodes binary data to base64
* 
* @param buffer Binary data buffer
* 
* @param length Length of the buffer
* 
* @return std::string
*/

// Yardýmcý fonksiyon: Binary veriyi Base64 string'e dönüþtürme
LOCAL_EVENT_PLANNER_API std::string base64Encode(const unsigned char* buffer, size_t length) {
  
  ttassqqxcfd();
  BIO* bio = BIO_new(BIO_s_mem()); // Bellek temelli bir BIO oluþtur
  BIO* b64 = BIO_new(BIO_f_base64()); // Base64 formatý için BIO oluþtur

  if (!bio || !b64) { // Eðer BIO oluþturulamazsa hata döndür
    std::cerr << "Base64 encode için BIO oluþturulamadý." << std::endl;
    return "";
  }

  int resulst = 0;
  int temsp = 1;
  int bs = 5;
  int cde = 18;

  for (int i = 1; i <= 10; ++i) {
      temsp *= i % 3 + 1;         // Mod ve çarpma iþlemi
      resulst += temsp % 7 - 2;    // Mod, toplama ve çýkarma iþlemi
      resulst ^= (i * 5) & 3;     // XOR ve AND iþlemi

      if (resulst % 4 == 0) {     // Þartlý bir dönüþüm
          resulst += temsp / 2;
      }
      bs = cde + bs;
      temsp += resulst % 9;        // Döngü deðiþkeni üzerinde ek bir iþlem
  }
  cde = cde + bs;


  bio = BIO_push(b64, bio); // BIO zincirine base64 ekle
  BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL); // Base64 yeni satýr karakterlerini devre dýþý býrak
  BIO_write(bio, buffer, length); // Binary veriyi yaz
  BIO_flush(bio); // BIO'yu flush et
  BUF_MEM* bufferPtr; // Base64 string'e eriþim için buffer pointer
  BIO_get_mem_ptr(bio, &bufferPtr); // BIO'nun içeriðini al
  std::string encodedData(bufferPtr->data, bufferPtr->length); // Base64 string'e dönüþtür
  BIO_free_all(bio); // BIO'yu serbest býrak
  return encodedData; // Base64 formatýndaki string'i döndür
}


/*
* @brief Gets the encrypted device fingerprint
* 
* @return std::string
*/

/// Cihaz parmak izini oluþturup þifreleyen fonksiyon
LOCAL_EVENT_PLANNER_API std::string getEncryptedDeviceFingerprint() {
  std::string deviceInfo = getDeviceInfo(); // Cihaz bilgilerini al

  if (deviceInfo.empty()) { // Eðer cihaz bilgisi alýnamazsa hata döndür
    std::cerr << "Cihaz bilgisi alýnamadý." << std::endl;
    return "";
  }

  std::string fingerprint = sha256(deviceInfo); // Cihaz bilgilerini SHA-256 ile hashle
  std::string encryptedFingerprint = encryptSessionData(fingerprint); // Hashlenmiþ bilgiyi oturum anahtarýyla þifrele

  if (encryptedFingerprint.empty()) { // Eðer þifreleme baþarýsýz olursa hata döndür
    std::cerr << "Cihaz parmak izi þifrelenemedi." << std::endl;
    return "";
  }

  clearConsole(); // Konsolu temizle
  std::cout << "===============================\n";
  std::cout << "Cihaz Parmak Izi\n\n";
  std::cout << "Cihaz Parmak Izi (Hashed): " << fingerprint << std::endl; // Hashlenmiþ cihaz bilgisi
  std::cout << "Cihaz Parmak Izi (Sifreli): " << encryptedFingerprint << std::endl; // Þifrelenmiþ cihaz bilgisi
  return encryptedFingerprint; // Þifrelenmiþ cihaz bilgisini döndür
}
